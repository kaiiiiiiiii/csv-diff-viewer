use wasm_bindgen::prelude::*;
use std::cell::Cell;
use std::thread_local;
use std::sync::atomic::{AtomicUsize, Ordering};

/// WASM memory allocation helpers and last binary result metadata

/// Storage for last binary result length using atomic operations for thread safety
static LAST_BINARY_RESULT_LENGTH: AtomicUsize = AtomicUsize::new(0);
static LAST_BINARY_RESULT_CAPACITY: AtomicUsize = AtomicUsize::new(0);

/// Get the last binary result length
/// 
/// Returns the length in bytes of the last binary-encoded result
#[wasm_bindgen]
pub fn get_last_binary_result_length() -> usize {
    LAST_BINARY_RESULT_LENGTH.load(Ordering::Relaxed)
}

/// Get the last binary result capacity
/// 
/// Returns the capacity in bytes of the last binary-encoded result
#[wasm_bindgen]
pub fn get_last_binary_result_capacity() -> usize {
    LAST_BINARY_RESULT_CAPACITY.load(Ordering::Relaxed)
}

// Thread-local dummy variable to ensure TLS initialization symbols
// like `__wasm_init_tls` are emitted in the final WASM binary
// when building with `parallel` feature enabled.
// This is required for wasm-bindgen-rayon to prepare the module
// for threading.
// Use the stable `thread_local!` macro to ensure a thread-local symbol
// is emitted. This generates necessary TLS init data which wasm-bindgen
// expects to find (`__wasm_init_tls`) when preparing the module for
// threading. We only enable it for wasm32 + parallel feature.
#[cfg(all(target_arch = "wasm32", feature = "parallel"))]
thread_local! {
    static WASM_THREAD_TLS_DUMMY: Cell<u32> = Cell::new(0);
}

// Do NOT define `__tls_size` / `__tls_align` manually here.
// The Rust compiler and linker emit TLS-related symbols automatically
// for wasm32 targets; defining them here creates type conflicts with
// the internal compiler-generated globals and results in link-time
// errors such as `duplicate symbol: __tls_size`.
// Instead, rely on the compiler definitions and export them using
// the linker args `--export=__tls_size` and `--export=__tls_align`.

// Provide a minimal TLS initializer symbol so `wasm-bindgen` can prepare
// the module for threading. In some toolchains the TLS initialization
// symbol isn't emitted automatically, which causes wasm-bindgen to error
// during the "prepare for threads" transformation.
// `__wasm_init_tls` should now be generated by the presence of the
// `thread_local!` symbol above; avoid providing a duplicate symbol to
// prevent linker errors.

/// Allocate memory in the WASM heap
/// 
/// # Arguments
/// * `size` - The number of bytes to allocate
/// 
/// # Returns
/// A raw pointer to the allocated memory
#[wasm_bindgen]
pub fn alloc(size: usize) -> *mut u8 {
    let mut buf = Vec::with_capacity(size);
    let ptr = buf.as_mut_ptr();
    std::mem::forget(buf);
    ptr
}

/// Deallocate memory in the WASM heap
/// 
/// # Arguments
/// * `ptr` - Pointer to the memory to deallocate
/// * `size` - The size of the memory block in bytes
#[wasm_bindgen]
pub fn dealloc(ptr: *mut u8, size: usize) {
    if ptr.is_null() {
        return;
    }
    unsafe {
        let _ = Vec::from_raw_parts(ptr, 0, size);
    }
}

pub(crate) fn set_last_binary_result_length(len: usize) {
    LAST_BINARY_RESULT_LENGTH.store(len, Ordering::Relaxed);
}

pub(crate) fn set_last_binary_result_capacity(cap: usize) {
    LAST_BINARY_RESULT_CAPACITY.store(cap, Ordering::Relaxed);
}

/// Get the binary result length (alias for get_last_binary_result_length)
/// 
/// Returns the length in bytes of the last binary-encoded result
#[wasm_bindgen]
pub fn get_binary_result_length() -> usize {
    LAST_BINARY_RESULT_LENGTH.load(Ordering::Relaxed)
}

/// Get the binary result capacity (alias for get_last_binary_result_capacity)
/// 
/// Returns the capacity in bytes of the last binary-encoded result
#[wasm_bindgen]
pub fn get_binary_result_capacity() -> usize {
    LAST_BINARY_RESULT_CAPACITY.load(Ordering::Relaxed)
}
